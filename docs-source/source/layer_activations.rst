Features / layer activations
============================

Once a model has been fully trained and evaluated, you may use the model to generate features from layer activations to gain better insight into the kinds of image features the model has learned.

Mosaic maps
***********

The easiest way to get started with layer activations is to calculate and display these features as a mosaic map. Mosaic maps are generated by calculating features from layer activations from a dataset (via :class:`slideflow.model.DatasetFeatures`), performing dimensionality reduction (UMAP) on the activations (via :class:`slideflow.SlideMap`), and overlaying tile images onto the UMAP (via :class:`slideflow.Mosaic`). By default, the post-convolutional ('postconv') layer is used when calculating features, but any combination of other layers can be also be used. The ``Project`` class has a function which can supervise these steps automatically and save the final figure to the project directory:

.. code-block:: python

    project.generate_mosaic(
        model="/path/to/saved/model.h5",
        mosaic_filename="/path/to/destination/mosaic.png",
        filters={"dataset": ["evaluation"]})

.. autofunction:: slideflow.Project.generate_mosaic
   :noindex:

.. image:: mosaic_example.png

If you provide a filename to the ``umap_filename`` argument, a plot of the constituent tiles will also be saved. If you additionally provide an outcome header (as saved in the annotations file) to the argument ``outcome_label_headers``, these tiles will be colored according to the slide-level annotation in the provided outcome header column of the annotations file.

Instead of mapping all tiles within a slide, you can choose instead to map only centroid tiles by passing ``map_slide='centroid'``.

There are many additional arguments that can be provided to the :meth:`slideflow.Project.generate_mosaic()` function to customize the mosaic and UMAP plots. However, you may choose to further customize these plots by working with the :class:`slideflow.Mosaic` object directly, which are returned from the ``generate_mosaic()`` function.

For example, it may be interesting to view a UMAP of tiles with an added third dimension, such as the activation value of a particular penultimate layer node. With this kind of plot, one can visualize how the activation of a particular node varies across the UMAP. To make such a plot, use the ``save_3d_node_plot`` function of the ``SlideMap``:

.. code-block:: python

    mosaic = project.generate_mosaic(
        model="/path/to/saved/model.h5",
        mosaic_filename="/path/to/destination/mosaic.png",
        filters={"dataset": ["evaluation"]})

    slide_map = mosiac.slide_map
    slide_map.save_3d_node_plot(node=497)

.. image:: 3d_umap.png

Working with Layer Features
***************************

To work more directly with features / intermediate layer activations, use either :class:`slideflow.model.Features` to generate features on a tile or slide level, or :class:`slideflow.model.DatasetFeatures` to generate features for an entire dataset.

Features
--------

The :class:`slideflow.model.Features` class can be used to generate layer activations / features for a single batch of images. For example, to calculate features for a batch of images while looping through a dataset:

.. code-block:: python

    from slideflow.model import Features

    features = Features(layer='postconv')
    for img_batch in dataset:
        postconv_features = features(img_batch)

You can choose to return features from any combination of intermediate layers by passing layer name(s) to the argument ``layer``. The interface can also return logits, by passing ``include_logits=True``.

To calculate layer features across an entire slide, the same interface can be called on a :class:`slideflow.WSI` object, generating a grid of activations of size ``(slide.grid.shape[0], slide.grid.shape[1], num_features)``:

.. code-block:: python

    from slideflow import WSI
    from slideflow.model import Features

    slide = WSI(...)
    interface = Features('/model/path', layers='postconv')
    feature_grid = interface(slide)

DatasetFeatures
---------------

The :class:`slideflow.model.DatasetFeatures` class is used to calculate and examine activations across an entire dataset. Instancing the class supervises the calculation and caching of layer activations, which can then be exported, viewed (as a mosaic map), or analyzed with various statistical methods. The project function :func:`slideflow.Project.generate_features` creates and returns an instance of this class.

.. code-block:: python

    features = P.generate_features(
        model='/path/to/trained_model',
        outcome_label_headers='HPV'
    )

Alternatively, you can create an instance of this class directly:

.. code-block:: python

    from slideflow.model import DatasetFeatures

    dataset = P.dataset(299, 302)

    features = DatasetFeatures(
        model='/path/to/trained_model',
        tfrecords=dataset.tfrecords(),
        annotations=dataset.labels('HPV')
    )

To return the average logits value for each slide (averaged across constituent tiles), use :func:`slideflow.model.DatasetFeatures.logits_mean`. Similarly, :func:`slideflow.model.DatasetFeatures.logits_predict` can be used to generate final slide-level logit predictions.

Featuresacross categories can be statistically compared using :func:`slideflow.model.DatasetFeatures.stats`, which will calculate and save statistics to a specified directory.

.. code-block:: python

    features.stats(outdir='/path', method='mean')

To compare layer features across outcome categories and find features which differ significantly across categories, use the :func:`slideflow.model.DatasetFeatures.box_plots` function:

.. image:: boxplot_example.png

Many other functions are available, as described in the documentation, :class:`slideflow.model.Features`.